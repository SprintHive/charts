apiVersion: v1
data:
  LICENSE: |2
                                     Apache License
                               Version 2.0, January 2004
                            http://www.apache.org/licenses/

       TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

       1. Definitions.

          "License" shall mean the terms and conditions for use, reproduction,
          and distribution as defined by Sections 1 through 9 of this document.

          "Licensor" shall mean the copyright owner or entity authorized by
          the copyright owner that is granting the License.

          "Legal Entity" shall mean the union of the acting entity and all
          other entities that control, are controlled by, or are under common
          control with that entity. For the purposes of this definition,
          "control" means (i) the power, direct or indirect, to cause the
          direction or management of such entity, whether by contract or
          otherwise, or (ii) ownership of fifty percent (50%) or more of the
          outstanding shares, or (iii) beneficial ownership of such entity.

          "You" (or "Your") shall mean an individual or Legal Entity
          exercising permissions granted by this License.

          "Source" form shall mean the preferred form for making modifications,
          including but not limited to software source code, documentation
          source, and configuration files.

          "Object" form shall mean any form resulting from mechanical
          transformation or translation of a Source form, including but
          not limited to compiled object code, generated documentation,
          and conversions to other media types.

          "Work" shall mean the work of authorship, whether in Source or
          Object form, made available under the License, as indicated by a
          copyright notice that is included in or attached to the work
          (an example is provided in the Appendix below).

          "Derivative Works" shall mean any work, whether in Source or Object
          form, that is based on (or derived from) the Work and for which the
          editorial revisions, annotations, elaborations, or other modifications
          represent, as a whole, an original work of authorship. For the purposes
          of this License, Derivative Works shall not include works that remain
          separable from, or merely link (or bind by name) to the interfaces of,
          the Work and Derivative Works thereof.

          "Contribution" shall mean any work of authorship, including
          the original version of the Work and any modifications or additions
          to that Work or Derivative Works thereof, that is intentionally
          submitted to Licensor for inclusion in the Work by the copyright owner
          or by an individual or Legal Entity authorized to submit on behalf of
          the copyright owner. For the purposes of this definition, "submitted"
          means any form of electronic, verbal, or written communication sent
          to the Licensor or its representatives, including but not limited to
          communication on electronic mailing lists, source code control systems,
          and issue tracking systems that are managed by, or on behalf of, the
          Licensor for the purpose of discussing and improving the Work, but
          excluding communication that is conspicuously marked or otherwise
          designated in writing by the copyright owner as "Not a Contribution."

          "Contributor" shall mean Licensor and any individual or Legal Entity
          on behalf of whom a Contribution has been received by Licensor and
          subsequently incorporated within the Work.

       2. Grant of Copyright License. Subject to the terms and conditions of
          this License, each Contributor hereby grants to You a perpetual,
          worldwide, non-exclusive, no-charge, royalty-free, irrevocable
          copyright license to reproduce, prepare Derivative Works of,
          publicly display, publicly perform, sublicense, and distribute the
          Work and such Derivative Works in Source or Object form.

       3. Grant of Patent License. Subject to the terms and conditions of
          this License, each Contributor hereby grants to You a perpetual,
          worldwide, non-exclusive, no-charge, royalty-free, irrevocable
          (except as stated in this section) patent license to make, have made,
          use, offer to sell, sell, import, and otherwise transfer the Work,
          where such license applies only to those patent claims licensable
          by such Contributor that are necessarily infringed by their
          Contribution(s) alone or by combination of their Contribution(s)
          with the Work to which such Contribution(s) was submitted. If You
          institute patent litigation against any entity (including a
          cross-claim or counterclaim in a lawsuit) alleging that the Work
          or a Contribution incorporated within the Work constitutes direct
          or contributory patent infringement, then any patent licenses
          granted to You under this License for that Work shall terminate
          as of the date such litigation is filed.

       4. Redistribution. You may reproduce and distribute copies of the
          Work or Derivative Works thereof in any medium, with or without
          modifications, and in Source or Object form, provided that You
          meet the following conditions:

          (a) You must give any other recipients of the Work or
              Derivative Works a copy of this License; and

          (b) You must cause any modified files to carry prominent notices
              stating that You changed the files; and

          (c) You must retain, in the Source form of any Derivative Works
              that You distribute, all copyright, patent, trademark, and
              attribution notices from the Source form of the Work,
              excluding those notices that do not pertain to any part of
              the Derivative Works; and

          (d) If the Work includes a "NOTICE" text file as part of its
              distribution, then any Derivative Works that You distribute must
              include a readable copy of the attribution notices contained
              within such NOTICE file, excluding those notices that do not
              pertain to any part of the Derivative Works, in at least one
              of the following places: within a NOTICE text file distributed
              as part of the Derivative Works; within the Source form or
              documentation, if provided along with the Derivative Works; or,
              within a display generated by the Derivative Works, if and
              wherever such third-party notices normally appear. The contents
              of the NOTICE file are for informational purposes only and
              do not modify the License. You may add Your own attribution
              notices within Derivative Works that You distribute, alongside
              or as an addendum to the NOTICE text from the Work, provided
              that such additional attribution notices cannot be construed
              as modifying the License.

          You may add Your own copyright statement to Your modifications and
          may provide additional or different license terms and conditions
          for use, reproduction, or distribution of Your modifications, or
          for any such Derivative Works as a whole, provided Your use,
          reproduction, and distribution of the Work otherwise complies with
          the conditions stated in this License.

       5. Submission of Contributions. Unless You explicitly state otherwise,
          any Contribution intentionally submitted for inclusion in the Work
          by You to the Licensor shall be under the terms and conditions of
          this License, without any additional terms or conditions.
          Notwithstanding the above, nothing herein shall supersede or modify
          the terms of any separate license agreement you may have executed
          with Licensor regarding such Contributions.

       6. Trademarks. This License does not grant permission to use the trade
          names, trademarks, service marks, or product names of the Licensor,
          except as required for reasonable and customary use in describing the
          origin of the Work and reproducing the content of the NOTICE file.

       7. Disclaimer of Warranty. Unless required by applicable law or
          agreed to in writing, Licensor provides the Work (and each
          Contributor provides its Contributions) on an "AS IS" BASIS,
          WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
          implied, including, without limitation, any warranties or conditions
          of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
          PARTICULAR PURPOSE. You are solely responsible for determining the
          appropriateness of using or redistributing the Work and assume any
          risks associated with Your exercise of permissions under this License.

       8. Limitation of Liability. In no event and under no legal theory,
          whether in tort (including negligence), contract, or otherwise,
          unless required by applicable law (such as deliberate and grossly
          negligent acts) or agreed to in writing, shall any Contributor be
          liable to You for damages, including any direct, indirect, special,
          incidental, or consequential damages of any character arising as a
          result of this License or out of the use or inability to use the
          Work (including but not limited to damages for loss of goodwill,
          work stoppage, computer failure or malfunction, or any and all
          other commercial damages or losses), even if such Contributor
          has been advised of the possibility of such damages.

       9. Accepting Warranty or Additional Liability. While redistributing
          the Work or Derivative Works thereof, You may choose to offer,
          and charge a fee for, acceptance of support, warranty, indemnity,
          or other liability obligations and/or rights consistent with this
          License. However, in accepting such obligations, You may act only
          on Your own behalf and on Your sole responsibility, not on behalf
          of any other Contributor, and only if You agree to indemnify,
          defend, and hold each Contributor harmless for any liability
          incurred by, or claims asserted against, such Contributor by reason
          of your accepting any such warranty or additional liability.

       END OF TERMS AND CONDITIONS

       APPENDIX: How to apply the Apache License to your work.

          To apply the Apache License to your work, attach the following
          boilerplate notice, with the fields enclosed by brackets "{}"
          replaced with your own identifying information. (Don't include
          the brackets!)  The text should be enclosed in the appropriate
          comment syntax for the file format. We also recommend that a
          file or class name and description of purpose be included on the
          same "printed page" as the copyright notice for easier
          identification within third-party archives.

       Copyright {yyyy} {name of copyright owner}

       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at

           http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.
  README.md: |-
    # Kong Prometheus Plugin

    Tracks internal kong metrics and exposes a prometheus endpoint on the Admin API to be scraped by a Prometheus Collector.

    ## Usage

    ```
    $ curl -X POST http://localhost:8001/plugins -d "name=prometheus"
    ```

    Now kong will track and monitor metrics across all apis and consumers.

    You can view these metrics by going to:

    ```
    http://localhost:8001/prometheus/metrics
    ```

    ## Metrics tracked

    - `kong_http_requests_total` - Number of HTTP requests
    - `kong_http_request_duration_seconds` - HTTP Request Latency
    - `kong_http_request_size_bytes` - HTTP Request Size Bytes
    - `kong_http_response_size_bytes` - HTTP Response Size Bytes
    - `kong_upstream_http_request_wait_duration_seconds` - Upstream HTTP Request Time to First Byte Latency
    - `kong_upstream_http_request_duration_seconds` - Upstream HTTP Request Latency
    - `kong_connections_active` - Total number of active connections
    - `kong_connections_reading` - Total number of connections reading
    - `kong_connections_writing` - Total number of connections writing
    - `kong_connections_waiting` - Total number of connections waiting

    ## Special Thanks

    - To `knyar` for their `nginx-lua-prometheus` client which this was built around and uses to track metrics.

    # Todo

    - [x] Implement Prometheus endpoint
    - [ ] Tests
  api.lua: |-
    local singletons           = require "kong.singletons"

    function send_raw(status_code, content)
      ngx.status = status_code
      ngx.say(content)
      ngx.exit(ngx.status)
    end

    return {
      ["/prometheus/metrics"] = {
        GET = function(self, dao_factory, helpers)
          singletons.prometheus_collectors.global.collector:collect()
          ngx.exit(200)
        end
      }
    }
  apply_config.sh: |-
    mkdir -p /usr/local/share/kong-extra-plugins/kong/plugins/prometheus;
    cp /tmp/prometheus-plugin-setup/*.lua /usr/local/share/kong-extra-plugins/kong/plugins/prometheus/;
    cd /usr/local/share/kong-extra-plugins/kong/plugins/prometheus/;
    chmod 755 ./*;
  client.lua: |-
    -- vim: ts=2:sw=2:sts=2:expandtab
    --
    -- This module uses a single dictionary shared between Nginx workers to keep
    -- all metrics. Each counter is stored as a separate entry in that dictionary,
    -- which allows us to increment them using built-in `incr` method.
    --
    -- Prometheus requires that (a) all samples for a given metric are presented
    -- as one uninterrupted group, and (b) buckets of a histogram appear in
    -- increasing numerical order. We satisfy that by carefully constructing full
    -- metric names (i.e. metric name along with all labels) so that they meet
    -- those requirements while being sorted alphabetically. In particular:
    --
    --  * all labels for a given metric are presented in reproducible order (the one
    --    used when labels were declared). "le" label for histogram metrics always
    --    goes last;
    --  * bucket boundaries (which are exposed as values of the "le" label) are
    --    presented as floating point numbers with leading and trailing zeroes.
    --    Number of of zeroes is determined for each bucketer automatically based on
    --    bucket boundaries;
    --  * internally "+Inf" bucket is stored as "Inf" (to make it appear after
    --    all numeric buckets), and gets replaced by "+Inf" just before we
    --    expose the metrics.
    --
    -- For example, if you define your bucket boundaries as {0.00005, 10, 1000}
    -- then we will keep the following samples for a metric `m1` with label
    -- `site` set to `site1`:
    --
    --   m1_bucket{site="site1",le="0000.00005"}
    --   m1_bucket{site="site1",le="0010.00000"}
    --   m1_bucket{site="site1",le="1000.00000"}
    --   m1_bucket{site="site1",le="Inf"}
    --   m1_count{site="site1"}
    --   m1_sum{site="site1"}
    --
    -- "Inf" will be replaced by "+Inf" while publishing metrics.
    --
    -- You can find the latest version and documentation at
    -- https://github.com/knyar/nginx-lua-prometheus
    -- Released under MIT license.


    -- Default set of latency buckets, 5ms to 10s:
    local DEFAULT_BUCKETS = {0.005, 0.01, 0.02, 0.03, 0.05, 0.075, 0.1, 0.2, 0.3,
                             0.4, 0.5, 0.75, 1, 1.5, 2, 3, 4, 5, 10}

    -- Metric is a "parent class" for all metrics.
    local Metric = {}
    function Metric:new(o)
      o = o or {}
      setmetatable(o, self)
      self.__index = self
      return o
    end

    -- Checks that the right number of labels values have been passed.
    --
    -- Args:
    --   label_values: an array of label values.
    --
    -- Returns:
    --   an error message or nil
    function Metric:check_label_values(label_values)
      if self.label_names == nil and label_values == nil then
        return
      elseif self.label_names == nil and label_values ~= nil then
        return "Expected no labels for " .. self.name .. ", got " ..  #label_values
      elseif label_values == nil and self.label_names ~= nil then
        return "Expected " .. #self.label_names .. " labels for " ..
               self.name .. ", got none"
      elseif #self.label_names ~= #label_values then
        return "Wrong number of labels for " .. self.name .. ". Expected " ..
               #self.label_names .. ", got " .. #label_values
      else
        for i, k in ipairs(self.label_names) do
          if label_values[i] == nil then
            return "Unexpected nil value for label " .. k ..  " of " .. self.name
          end
        end
      end
    end

    local Counter = Metric:new()
    -- Increase a given counter by `value`
    --
    -- Args:
    --   value: (number) a value to add to the counter. Defaults to 1 if skipped.
    --   label_values: an array of label values. Can be nil (i.e. not defined) for
    --     metrics that have no labels.
    function Counter:inc(value, label_values)
      local err = self:check_label_values(label_values)
      if err ~= nil then
        self.prometheus:log_error(err)
        return
      end
      self.prometheus:inc(self.name, self.label_names, label_values, value or 1)
    end

    local Gauge = Metric:new()
    -- Set a given gauge to `value`
    --
    -- Args:
    --   value: (number) a value to set the gauge to. Should be defined.
    --   label_values: an array of label values. Can be nil (i.e. not defined) for
    --     metrics that have no labels.
    function Gauge:set(value, label_values)
      if value == nil then
        self.prometheus:log_error("No value passed for " .. self.name)
        return
      end
      local err = self:check_label_values(label_values)
      if err ~= nil then
        self.prometheus:log_error(err)
        return
      end
      self.prometheus:set(self.name, self.label_names, label_values, value)
    end

    local Histogram = Metric:new()
    -- Record a given value in a histogram.
    --
    -- Args:
    --   value: (number) a value to record. Should be defined.
    --   label_values: an array of label values. Can be nil (i.e. not defined) for
    --     metrics that have no labels.
    function Histogram:observe(value, label_values)
      if value == nil then
        self.prometheus:log_error("No value passed for " .. self.name)
        return
      end
      local err = self:check_label_values(label_values)
      if err ~= nil then
        self.prometheus:log_error(err)
        return
      end
      self.prometheus:histogram_observe(self.name, self.label_names, label_values, value)
    end

    local Prometheus = {}
    Prometheus.__index = Prometheus
    Prometheus.initialized = false

    -- Generate full metric name that includes all labels.
    --
    -- Args:
    --   name: string
    --   label_names: (array) a list of label keys.
    --   label_values: (array) a list of label values.
    -- Returns:
    --   (string) full metric name.
    local function full_metric_name(name, label_names, label_values)
      if not label_names then
        return name
      end
      local label_parts = {}
      for idx, key in ipairs(label_names) do
        local label_value = (string.format("%s", label_values[idx])
          :gsub("[^\032-\126]", "")  -- strip non-printable characters
          :gsub("\\", "\\\\")
          :gsub('"', '\\"'))
        table.insert(label_parts, key .. '="' .. label_value .. '"')
      end
      return name .. "{" .. table.concat(label_parts, ",") .. "}"
    end

    -- Construct bucket format for a list of buckets.
    --
    -- This receives a list of buckets and returns a sprintf template that should
    -- be used for bucket boundaries to make them come in increasing order when
    -- sorted alphabetically.
    --
    -- To re-phrase, this is where we detect how many leading and trailing zeros we
    -- need.
    --
    -- Args:
    --   buckets: a list of buckets
    --
    -- Returns:
    --   (string) a sprintf template.
    local function construct_bucket_format(buckets)
      local max_order = 1
      local max_precision = 1
      for _, bucket in ipairs(buckets) do
        assert(type(bucket) == "number", "bucket boundaries should be numeric")
        -- floating point number with all trailing zeros removed
        local as_string = string.format("%f", bucket):gsub("0*$", "")
        local dot_idx = as_string:find(".", 1, true)
        max_order = math.max(max_order, dot_idx - 1)
        max_precision = math.max(max_precision, as_string:len() - dot_idx)
      end
      return "%0" .. (max_order + max_precision + 1) .. "." .. max_precision .. "f"
    end

    -- Extract short metric name from the full one.
    --
    -- Args:
    --   full_name: (string) full metric name that can include labels.
    --
    -- Returns:
    --   (string) short metric name with no labels. For a `*_bucket` metric of
    --     histogram the _bucket suffix will be removed.
    local function short_metric_name(full_name)
      local labels_start, _ = full_name:find("{")
      if not labels_start then
        -- no labels
        return full_name
      end
      local suffix_idx, _ = full_name:find("_bucket{")
      if suffix_idx and full_name:find("le=") then
        -- this is a histogram metric
        return full_name:sub(1, suffix_idx - 1)
      end
      -- this is not a histogram metric
      return full_name:sub(1, labels_start - 1)
    end

    -- Makes a shallow copy of a table
    local function copy_table(table)
      local new = {}
      if table ~= nil then
        for k, v in ipairs(table) do
          new[k] = v
        end
      end
      return new
    end

    -- Check metric name and label names for correctness.
    --
    -- Regular expressions to validate metric and label names are
    -- documented in https://prometheus.io/docs/concepts/data_model/
    --
    -- Args:
    --   metric_name: (string) metric name.
    --   label_names: label names (array of strings).
    --
    -- Returns:
    --   Either an error string, or nil of no errors were found.
    local function check_metric_and_label_names(metric_name, label_names)
      if not metric_name:match("^[a-zA-Z_:][a-zA-Z0-9_:]*$") then
        return "Metric name '" .. metric_name .. "' is invalid"
      end
      for _, label_name in ipairs(label_names or {}) do
        if label_name == "le" then
          return "Invalid label name 'le' in " .. metric_name
        end
        if not label_name:match("^[a-zA-Z_][a-zA-Z0-9_]*$") then
          return "Metric '" .. metric_name .. "' label name '" .. label_name ..
                 "' is invalid"
        end
      end
    end

    -- Initialize the module.
    --
    -- This should be called once from the `init_by_lua` section in nginx
    -- configuration.
    --
    -- Args:
    --   dict_name: (string) name of the nginx shared dictionary which will be
    --     used to store all metrics
    --   prefix: (optional string) if supplied, prefix is added to all
    --   metric names on output
    --
    -- Returns:
    --   an object that should be used to register metrics.
    function Prometheus.init(dict_name, prefix)
      local self = setmetatable({}, Prometheus)
      self.dict = ngx.shared[dict_name or "prometheus_metrics"]
      self.help = {}
      if prefix then
        self.prefix = prefix
      else
        self.prefix = ''
      end
      self.type = {}
      self.registered = {}
      self.buckets = {}
      self.bucket_format = {}
      self.initialized = true

      self:counter("kong_prometheus_collector_errors_total",
        "Number of Kong prometheus collector errors")
      self.dict:set("kong_prometheus_collector_errors_total", 0)
      return self
    end

    function Prometheus:log_error(...)
      ngx.log(ngx.ERR, ...)
      self.dict:incr("kong_prometheus_collector_errors_total", 1)
    end

    function Prometheus:log_error_kv(key, value, err)
      self:log_error(
        "Error while setting '", key, "' to '", value, "': '", err, "'")
    end

    -- Register a counter.
    --
    -- Args:
    --   name: (string) name of the metric. Required.
    --   description: (string) description of the metric. Will be used for the HELP
    --     comment on the metrics page. Optional.
    --   label_names: array of strings, defining a list of metrics. Optional.
    --
    -- Returns:
    --   a Counter object.
    function Prometheus:counter(name, description, label_names)
      if not self.initialized then
        ngx.log(ngx.ERR, "Prometheus module has not been initialized")
        return
      end

      local err = check_metric_and_label_names(name, label_names)
      if err ~= nil then
        self:log_error(err)
        return
      end

      if self.registered[name] then
        self:log_error("Duplicate metric " .. name)
        return
      end
      self.registered[name] = true
      self.help[name] = description
      self.type[name] = "counter"

      return Counter:new{name=name, label_names=label_names, prometheus=self}
    end

    -- Register a gauge.
    --
    -- Args:
    --   name: (string) name of the metric. Required.
    --   description: (string) description of the metric. Will be used for the HELP
    --     comment on the metrics page. Optional.
    --   label_names: array of strings, defining a list of metrics. Optional.
    --
    -- Returns:
    --   a Gauge object.
    function Prometheus:gauge(name, description, label_names)
      if not self.initialized then
        ngx.log(ngx.ERR, "Prometheus module has not been initialized")
        return
      end

      local err = check_metric_and_label_names(name, label_names)
      if err ~= nil then
        self:log_error(err)
        return
      end

      if self.registered[name] then
        self:log_error("Duplicate metric " .. name)
        return
      end
      self.registered[name] = true
      self.help[name] = description
      self.type[name] = "gauge"

      return Gauge:new{name=name, label_names=label_names, prometheus=self}
    end


    -- Register a histogram.
    --
    -- Args:
    --   name: (string) name of the metric. Required.
    --   description: (string) description of the metric. Will be used for the HELP
    --     comment on the metrics page. Optional.
    --   label_names: array of strings, defining a list of metrics. Optional.
    --   buckets: array if numbers, defining bucket boundaries. Optional.
    --
    -- Returns:
    --   a Histogram object.
    function Prometheus:histogram(name, description, label_names, buckets)
      if not self.initialized then
        ngx.log(ngx.ERR, "Prometheus module has not been initialized")
        return
      end

      local err = check_metric_and_label_names(name, label_names)
      if err ~= nil then
        self:log_error(err)
        return
      end

      for _, suffix in ipairs({"", "_bucket", "_count", "_sum"}) do
        if self.registered[name .. suffix] then
          self:log_error("Duplicate metric " .. name .. suffix)
          return
        end
        self.registered[name .. suffix] = true
      end
      self.help[name] = description
      self.type[name] = "histogram"

      self.buckets[name] = buckets or DEFAULT_BUCKETS
      self.bucket_format[name] = construct_bucket_format(self.buckets[name])

      return Histogram:new{name=name, label_names=label_names, prometheus=self}
    end

    -- Set a given dictionary key.
    -- This overwrites existing values, so it should only be used when initializing
    -- metrics or when explicitely overwriting the previous value of a metric.
    function Prometheus:set_key(key, value)
      local ok, err = self.dict:safe_set(key, value)
      if not ok then
        self:log_error_kv(key, value, err)
      end
    end

    -- Increment a given counter by `value`.
    --
    -- Args:
    --   name: (string) short metric name without any labels.
    --   label_names: (array) a list of label keys.
    --   label_values: (array) a list of label values.
    --   value: (number) value to add. Optional, defaults to 1.
    function Prometheus:inc(name, label_names, label_values, value)
      local key = full_metric_name(name, label_names, label_values)
      if value == nil then value = 1 end
      if value < 0 then
        self:log_error_kv(key, value, "Value should not be negative")
        return
      end

      local newval, err = self.dict:incr(key, value)
      if newval then
        return
      end
      -- Yes, this looks like a race, so I guess we might under-report some values
      -- when multiple workers simultaneously try to create the same metric.
      -- Hopefully this does not happen too often (shared dictionary does not get
      -- reset during configuation reload).
      if err == "not found" then
        self:set_key(key, value)
        return
      end
      -- Unexpected error
      self:log_error_kv(key, value, err)
    end

    -- Set the current value of a gauge to `value`
    --
    -- Args:
    --   name: (string) short metric name without any labels.
    --   label_names: (array) a list of label keys.
    --   label_values: (array) a list of label values.
    --   value: (number) the new value for the gauge.
    function Prometheus:set(name, label_names, label_values, value)
      local key = full_metric_name(name, label_names, label_values)
      self:set_key(key, value)
    end

    -- Record a given value into a histogram metric.
    --
    -- Args:
    --   name: (string) short metric name without any labels.
    --   label_names: (array) a list of label keys.
    --   label_values: (array) a list of label values.
    --   value: (number) value to observe.
    function Prometheus:histogram_observe(name, label_names, label_values, value)
      self:inc(name .. "_count", label_names, label_values, 1)
      self:inc(name .. "_sum", label_names, label_values, value)

      -- we are going to mutate arrays of label names and values, so create a copy.
      local l_names = copy_table(label_names)
      local l_values = copy_table(label_values)

      -- Last bucket. Note, that the label value is "Inf" rather than "+Inf"
      -- required by Prometheus. This is necessary for this bucket to be the last
      -- one when all metrics are lexicographically sorted. "Inf" will get replaced
      -- by "+Inf" in Prometheus:collect().
      table.insert(l_names, "le")
      table.insert(l_values, "Inf")
      self:inc(name .. "_bucket", l_names, l_values, 1)

      local label_count = #l_names
      for _, bucket in ipairs(self.buckets[name]) do
        if value <= bucket then
          -- last label is now "le"
          l_values[label_count] = self.bucket_format[name]:format(bucket)
          self:inc(name .. "_bucket", l_names, l_values, 1)
        end
      end
    end

    -- Present all metrics in a text format compatible with Prometheus.
    --
    -- This function should be used to expose the metrics on a separate HTTP page.
    -- It will get the metrics from the dictionary, sort them, and expose them
    -- aling with TYPE and HELP comments.
    function Prometheus:collect()
      ngx.header.content_type = "text/plain"
      if not self.initialized then
        ngx.log(ngx.ERR, "Prometheus module has not been initialized")
        return
      end

      local keys = self.dict:get_keys(0)
      -- Prometheus server expects buckets of a histogram to appear in increasing
      -- numerical order of their label values.
      table.sort(keys)

      local seen_metrics = {}
      for _, key in ipairs(keys) do
        local value, err = self.dict:get(key)
        if value then
          local short_name = short_metric_name(key)
          if not seen_metrics[short_name] then
            if self.help[short_name] then
              ngx.say("# HELP " .. self.prefix .. short_name .. " " .. self.help[short_name])
            end
            if self.type[short_name] then
              ngx.say("# TYPE " .. self.prefix .. short_name .. " " .. self.type[short_name])
            end
            seen_metrics[short_name] = true
          end
          -- Replace "Inf" with "+Inf" in each metric's last bucket 'le' label.
          ngx.say(self.prefix .. key:gsub('le="Inf"', 'le="+Inf"'), " ", value)
        else
          self:log_error("Error getting '", key, "': ", err)
        end
      end
    end

    -- Debug output for prometheus metrics
    function Prometheus:debug()
      ngx.header.content_type = "text/plain"
      if not self.initialized then
        ngx.log(ngx.ERR, "Prometheus module has not been initialized")
        return
      end

      local keys = self.dict:get_keys(0)
      -- Prometheus server expects buckets of a histogram to appear in increasing
      -- numerical order of their label values.
      table.sort(keys)

      local seen_metrics = {}
      for _, key in ipairs(keys) do
        local value, err = self.dict:get(key)
        if value then
          local short_name = short_metric_name(key)
          if not seen_metrics[short_name] then
            if self.help[short_name] then
              ngx.log(ngx.ERR, "# HELP " .. self.prefix .. short_name .. " " .. self.help[short_name])
            end
            if self.type[short_name] then
              ngx.log(ngx.ERR, "# TYPE " .. self.prefix .. short_name .. " " .. self.type[short_name])
            end
            seen_metrics[short_name] = true
          end
          -- Replace "Inf" with "+Inf" in each metric's last bucket 'le' label.
          ngx.log(ngx.ERR, self.prefix .. key:gsub('le="Inf"', 'le="+Inf"'), " ", value)
        else
          ngx.log(ngx.ERR, "Error getting '", key, "': ", err)
        end
      end
    end


    return Prometheus
  dict.lua: |-
    local SharedDict = {}
    local function set(data, key, value)
      data[key] = {
        value = value,
        info = {expired = false}
      }
    end
    function SharedDict:new()
      return setmetatable({data = {}}, {__index = self})
    end
    function SharedDict:get(key)
      return self.data[key] and self.data[key].value, nil
    end
    function SharedDict:set(key, value)
      set(self.data, key, value)
      return true, nil, false
    end
    SharedDict.safe_set = SharedDict.set
    function SharedDict:add(key, value, exptime)
      if self.data[key] ~= nil then
        return false, "exists", false
      end

      if exptime then
        ngx.timer.at(exptime, function()
          self.data[key] = nil
        end)
      end

      set(self.data, key, value)
      return true, nil, false
    end
    SharedDict.safe_add = SharedDict.add
    function SharedDict:replace(key, value)
      if self.data[key] == nil then
        return false, "not found", false
      end
      set(self.data, key, value)
      return true, nil, false
    end
    function SharedDict:delete(key)
      if self.data[key] ~= nil then
        self.data[key] = nil
      end
      return true
    end
    function SharedDict:incr(key, value, init)
      if not self.data[key] then
        if not init then
          return nil, "not found"
        else
          self.data[key] = { value = init }
        end
      elseif type(self.data[key].value) ~= "number" then
        return nil, "not a number"
      end
      self.data[key].value = self.data[key].value + value
      return self.data[key].value, nil
    end
    function SharedDict:flush_all()
      for _, item in pairs(self.data) do
        item.info.expired = true
      end
    end
    function SharedDict:flush_expired(n)
      local data = self.data
      local flushed = 0

      for key, item in pairs(self.data) do
        if item.info.expired then
          data[key] = nil
          flushed = flushed + 1
          if n and flushed == n then
            break
          end
        end
      end
      self.data = data
      return flushed
    end
    function SharedDict:get_keys(n)
      n = n or 1024
      local i = 0
      local keys = {}
      for k in pairs(self.data) do
        keys[#keys+1] = k
        i = i + 1
        if n ~= 0 and i == n then
          break
        end
      end
      return keys
    end

    return function (name)
      local d = SharedDict:new()
      ngx.shared[name] = d
      return d
    end
  handler.lua: "-- Core Modules\nlocal singletons           = require \"kong.singletons\"\nlocal
    base_plugin          = require \"kong.plugins.base_plugin\"\nlocal shared_dict
    \         = require \"kong.plugins.prometheus.dict\"\nlocal prometheus           =
    require \"kong.plugins.prometheus.client\"\n\n-- External Stats Collectors\nlocal
    basic_metrics        = require \"kong.plugins.log-serializers.basic\"\n\n-- Plugin
    objects\nlocal prometheus_plugin    = base_plugin:extend()\n\n-- Plugin singletons\nsingletons.prometheus_collectors
    \ = {}\n\n-- Plugin constructor\nfunction prometheus_plugin:new()\n  prometheus_plugin.super.new(self,
    \"prometheus\")\n  \n  -- Initialize Prometheus Collector Object\n  local global_dict
    = shared_dict(\"kong_prometheus_global_dict\")\n  local global_collector = prometheus.init(\"kong_prometheus_global_dict\")\n
    \ local global_metrics = {}\n\n  singletons.prometheus_collectors.global = {\n
    \   dict = global_dict,\n    collector = global_collector,\n    metrics = global_metrics\n
    \ }\n\n  -- Stat Objects\n  local generic_stats = {\"protocol\", \"host\", \"port\",
    \"path\", \"status\", \"remote_addr\", \"api_id\", \"consumer_id\"}\n  local entity_stats
    = {\"api_id\", \"consumer_id\"}\n\n  -- Initialize Metric Buckets\n  global_metrics.request_count
    = global_collector:counter(\n    \"kong_http_requests_total\", \"Number of HTTP
    requests\", generic_stats)\n\n  global_metrics.request_latency = global_collector:histogram(\n
    \   \"kong_http_request_duration_seconds\", \"HTTP Request Latency\", generic_stats)\n\n
    \ global_metrics.request_size = global_collector:counter(\n    \"kong_http_request_size_bytes\",
    \"HTTP Request Size Bytes\", generic_stats)\n\n  global_metrics.response_size
    = global_collector:counter(\n    \"kong_http_response_size_bytes\", \"HTTP Response
    Size Bytes\", generic_stats)\n\n  global_metrics.proxy_first_byte_latency = global_collector:histogram(\n
    \   \"kong_upstream_http_request_wait_duration_seconds\", \"Upstream HTTP Request
    Time to First Byte Latency\", generic_stats)\n\n  global_metrics.proxy_latency
    = global_collector:histogram(\n    \"kong_upstream_http_request_duration_seconds\",
    \"Upstream HTTP Request Latency\", generic_stats)\n\n  global_metrics.connections_active
    = global_collector:counter(\n    \"kong_connections_active\", \"Total number of
    active connections\")\n\n  global_metrics.connections_reading = global_collector:counter(\n
    \   \"kong_connections_reading\", \"Total number of connections reading\")\n\n
    \ global_metrics.connections_writing = global_collector:counter(\n    \"kong_connections_writing\",
    \"Total number of connections writing\")\n\n  global_metrics.connections_waiting
    = global_collector:counter(\n    \"kong_connections_waiting\", \"Total number
    of connections waiting\")\nend\n\n---[[ runs in the 'log_by_lua_block'\nfunction
    prometheus_plugin:log(plugin_conf)\n  prometheus_plugin.super.access(self)\n\n
    \ -- Get Prometheus collector metrics object\n  local metrics = singletons.prometheus_collectors.global.metrics\n
    \ local collector = singletons.prometheus_collectors.global.collector\n\n  --
    Get Basic Stats\n  local stats = basic_metrics.serialize(ngx)\n\n  -- Get Authenticated
    / API values\n  local api_id = (stats.api and stats.api.id or 'global')\n  local
    consumer_id = (stats.authenticated_entity and stats.authenticated_entity.consumer_id
    or 'anonymous')\n\n  -- Extend request stats\n  stats.request.protocol = ngx.var.scheme\n
    \ stats.request.host = ngx.var.host:gsub(\"^www.\", \"\")\n  stats.request.port
    = ngx.var.server_port\n\n  -- General details object\n  local request_details
    = {\n    stats.request.protocol,\n    stats.request.host,\n    stats.request.port,\n
    \   stats.request.uri,\n    stats.response.status,\n    stats.client_ip,\n    api_id,\n
    \   consumer_id\n  }\n\n  -- Entity detail object\n  local entity_details = {\n
    \   api_id,\n    consumer_id\n  }\n\n  -- Basic Connection metrics\n  metrics.connections_active:inc(tonumber(ngx.var.connections_active))\n
    \ metrics.connections_reading:inc(tonumber(ngx.var.connections_reading))\n  metrics.connections_waiting:inc(tonumber(ngx.var.connections_waiting))\n
    \ metrics.connections_writing:inc(tonumber(ngx.var.connections_writing))\n\n  --
    Request Latency\n  metrics.request_latency:observe(ngx.now() - ngx.req.start_time(),
    request_details)\n\n  -- Request Count\n  metrics.request_count:inc(1, request_details)\n\n
    \ -- Sizes\n  metrics.request_size:inc(tonumber(ngx.var.request_length), request_details)\n
    \ metrics.response_size:inc(tonumber(ngx.var.bytes_sent), request_details)\n\n
    \ -- Proxy Latency\n  if ngx.ctx.KONG_PROXIED then\n    -- Add the time waiting
    for upstream response and response handle time\n    -- to determine the total
    upstream time taken\n    local kong_wait_time = ngx.ctx.KONG_WAITING_TIME or 0\n
    \   local kong_receive_time = ngx.ctx.KONG_RECEIVE_TIME or 0\n    local kong_upstream_time
    = kong_wait_time + kong_receive_time\n\n    metrics.proxy_first_byte_latency:observe(kong_wait_time
    / 1000, request_details)\n    metrics.proxy_latency:observe(kong_upstream_time
    / 1000, request_details)\n  end\n\n  -- collector:debug()\nend --]]\n\n-- set
    the plugin priority, which determines plugin execution order\nprometheus_plugin.PRIORITY
    = 1000\n\n-- return our plugin object\nreturn prometheus_plugin\n"
  kong-plugin-prometheus-1.0.0-1.rockspec: |
    package = "kong-plugin-prometheus"
    version = "1.0.0-1"

    supported_platforms = {"linux", "macosx"}
    source = {
      url = "git://github.com/nijikokun/kong-plugin-prometheus",
      tag = "1.0.0"
    }

    description = {
      summary = "Kong Prometheus plugin exposes a Prometheus Metrics endpoint to be used by the Prometheus Gateway",
      homepage = "http://getkong.org",
      license = "MIT"
    }

    dependencies = {
    }

    build = {
      type = "builtin",
      modules = {
        ["kong.plugins.prometheus.handler"] = "kong/plugins/prometheus/handler.lua",
        ["kong.plugins.prometheus.schema"] = "kong/plugins/prometheus/schema.lua",
        ["kong.plugins.prometheus.client"] = "kong/plugins/prometheus/client.lua",
        ["kong.plugins.prometheus.dict"] = "kong/plugins/prometheus/dict.lua",
        ["kong.plugins.prometheus.api"] = "kong/plugins/prometheus/api.lua",
      }
    }
  schema.lua: "return {\n  no_consumer = false, -- this plugin is available on APIs
    as well as on Consumers,\n  fields = {\n    -- Describe your plugin's configuration's
    schema here.\n    \n  },\n  self_check = function(schema, plugin_t, dao, is_updating)\n
    \   -- perform any custom verification\n    return true\n  end\n}\n"
kind: ConfigMap
metadata:
  creationTimestamp: 2018-01-25T13:29:53Z
  name: prometheus-plugin-setup
  namespace: infra
  resourceVersion: "73179"
  selfLink: /api/v1/namespaces/infra/configmaps/prometheus-plugin-setup
  uid: d3df7b75-01d3-11e8-86e6-080027f34421
